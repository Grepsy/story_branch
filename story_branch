#!/usr/bin/env ruby
# -*- coding: utf-8 -*-

# Name: story_branch (recommend: setting a git alias as "git story")
#
# Author: Jason Milkins <jason@opsmanager.com> & Gabe Hollombe <gabe@neo.com>
#
# Description:
# Create a git branch with automatic reference to a Pivotal Tracker Story ID
#
# Commentary:
# By default story_branch will present a list of started stories from
# your active PivotalTracker project, you select one and then provide
# a feature branch name for that story. The branch will be created and
# the name will include the story_id as a suffix.
#
# Changelog:
#
# Milestone 'porus-flapjack'
# * Present safe version of story name (dash-cased) for editing
# * Provide readline editing
#
# Current Features being added:
# TODO: Validate that branchname is 'legal'
# TODO: Validate that branchname doesn't already exist (check name with and without pivotal tracker id)
#
# Backlog:
# Nothing...

def friendly_require gem, name=nil
  begin
    require gem
  rescue LoadError
    name = gem if name.nil?
    puts "The #{name} gem must be installed"
    exit
  end
end

def env_required var_name
  if ENV[var_name].nil?
    puts "#{var_name} must be set in your environment."
    exit
  end
  ENV[var_name]
end

def dash_cased s
  s.tr(' ', '-')
end

def validate_branch_name name
  unless validate_branch_name? name
    puts "Error: #{name}\nis an invalid name."
    return false
  end
  unless is_existing_branch? name
    puts "Error: #{name}\nmatches the name of an existing branch, a unique name is required"
  end
end

def valid_branch_name? name
  valid = /[a-zA-Z][-._0-9a-zA-Z]*/
  name.match valid
end

def is_existing_branch? name
  # we don't use the Git gem's is_local_branch? because we want to
  # ignore the id suffix while still avoiding name collisions
  git_branch_names.each do |n|
    puts n
  end
end

def git_branch_names
  g = Git.open "."
  g.branches.map(&:name)
end

def git_current_branch
  g = Git.open "."
  g.current_branch
end

def git_create_branch name
  g = Git.open "."
  g.branch(feature_branch_name_with_story_id).create
  g.branch(feature_branch_name_with_story_id).checkout
end

def list_pivotal_stories api_key, project_id
  PivotalTracker::Client.token = api_key
  project = PivotalTracker::Project.find(project_id.to_i)
  stories = project.stories.all({current_state: :started})
  stories.each_with_index{|s,i| puts "[#{i+1}] ##{s.id} : #{s.name}"}
  stories
end

def readline prompt, history=[]
  if history.length > 0
    history.each {|i| Readline::HISTORY.push i}
  end
  begin
    Readline.readline(prompt, false)
  rescue Interrupt
    exit
  end
end

def select_story stories
  story_selection = nil
  while story_selection == nil or story_selection == 0 or story_selection > stories.length + 1
    puts "invalid selection" if story_selection != nil
    story_selection = readline("Select a story: ", Range.new(1,stories.length).to_a.map(&:to_s)).to_i
  end
  story = stories[story_selection - 1]
  puts "Selected : ##{story.id} : #{story.name}"
  return story
end

def create_feature_branch story
  current_branch = git_current_branch
  dashed_story_name = (dash_cased story.name)[0..50].downcase
  feature_branch_name = nil

  puts "You are checked out at: #{current_branch}"

  if current_branch == "master"
    while feature_branch_name == nil or feature_branch_name == ""
      puts "Provide a new branch name..." if [nil, ""].include? feature_branch_name
      feature_branch_name = readline("Name of feature branch: ", [dashed_story_name])
    end
    feature_branch_name.chomp!

    validate_branch_name

    feature_branch_name_with_story_id = "#{feature_branch_name}-#{story.id}"

    # Create branch in git repo...
    puts "Creating: #{feature_branch_name_with_story_id}"
    git_create_branch feature_branch_name_with_story_id

  else
    puts "Feature branches must be created from 'master'"
  end
end

#require
friendly_require 'pivotal-tracker'
friendly_require 'readline'
friendly_require 'git'
friendly_require 'levenshtein', 'levenshtein-ffi'
# env
api_key = env_required 'PIVOTAL_API_KEY'
project_id = env_required 'PIVOTAL_PROJECT_ID'

def pivotal_story_branch api_key, project_id
  # do it...
  stories = list_pivotal_stories api_key, project_id
  story = select_story stories
  create_feature_branch story
end

# pivotal_story_branch api_key, project_id
git_branch_names
